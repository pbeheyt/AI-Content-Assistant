(function() {
    function getVisibleText() {
        let bodyText = '';

        function extractText(node) {
            if (node.nodeType === Node.TEXT_NODE) {
                if (node.textContent.trim().length > 0) {
                    return node.textContent;
                }
                return '';
            } else if (node.nodeType === Node.ELEMENT_NODE) {
                const tagName = node.tagName.toLowerCase();
                const excludedTags = ['script', 'style', 'img', 'svg', 'footer', 'nav', 'noscript'];

                if (excludedTags.includes(tagName)) {
                    return '';
                }

                const style = window.getComputedStyle(node);
                if (style.display !== 'none' && style.visibility !== 'hidden') {
                    let text = '';
                    node.childNodes.forEach(child => {
                        text += extractText(child);
                    });
                    return text;
                }
                return '';
            }
            return '';
        }

        document.body.childNodes.forEach(child => {
            bodyText += extractText(child);
        });

        return bodyText.trim();
    }

    const selectedText = window.getSelection().toString().trim();
    const textToSummarize = selectedText || getVisibleText();

    if (textToSummarize) {
        chrome.storage.local.set({ selectedText: textToSummarize }, () => {
            console.log('Text to summarize saved:', textToSummarize);
            chrome.runtime.sendMessage({
                action: 'openGPT'
            });
        });
    } else {
        alert('No text found on the page.');
    }
})();
chrome.runtime.onInstalled.addListener(async () => {
    chrome.contextMenus.create({
        id: "summarizeLinkedPage",
        title: "Summarize page",
        contexts: ["link"]
    });

    chrome.contextMenus.create({
        id: "summarizePage",
        title: "Summarize page",
        contexts: ["page"]
    });

    chrome.contextMenus.create({
        id: "summarizeSelectedText",
        title: "Summarize",
        contexts: ["selection"]
    });

    chrome.contextMenus.create({
        id: "exploreSelectedText",
        title: "Explore",
        contexts: ["selection"]
    });

    const response = await fetch(chrome.runtime.getURL('config.json'));
    const config = await response.json();
    await chrome.storage.local.set({ gptConfig: config });
});


chrome.contextMenus.onClicked.addListener(async (info, tab) => {
    let configKey = "";
    if (info.menuItemId === "summarizeSelectedText") {
        configKey = "chatgptSummaryUrl";
    } else if (info.menuItemId === "exploreSelectedText") {
        configKey = "chatgptExplorerUrl";
    }

    const response = await fetch(chrome.runtime.getURL('config.json'));
    const config = await response.json();
    const gptUrl = config[configKey];

    await chrome.storage.local.set({ gptUrl });

    if (info.menuItemId === "summarizeLinkedPage") {
        await chrome.storage.local.set({ launchedViaContextMenu: true });
        const url = info.linkUrl;
        const newTab = await chrome.tabs.create({ url, active: false });
        await chrome.storage.local.set({ contentTabId: newTab.id });
        await chrome.scripting.executeScript({
            target: { tabId: newTab.id },
            files: ['content.js']
        });

        chrome.tabs.onUpdated.addListener(function contentTabListener(tabId, changeInfo) {
            if (tabId === newTab.id && changeInfo.status === 'complete') {
                chrome.tabs.onUpdated.removeListener(contentTabListener);
            }
        });
    } else if (["summarizePage", "summarizeSelectedText", "exploreSelectedText"].includes(info.menuItemId)) {
        const tabs = await chrome.tabs.query({ active: true, currentWindow: true });
        await chrome.scripting.executeScript({
            target: { tabId: tabs[0].id },
            files: ['content.js']
        });
        chrome.runtime.sendMessage({ action: 'openGPT' });
    }
});

chrome.tabs.onUpdated.addListener(async (tabId, changeInfo, tab) => {
    if (changeInfo.status === 'complete' && tab.url && tab.url.includes('chatgpt.com')) {
        const { gptConfig } = await chrome.storage.local.get('gptConfig');
        const gptUrls = [
            gptConfig.chatgptSummaryUrl,
            gptConfig.chatgptExplorerUrl
        ];

        if (gptUrls.some(url => tab.url.includes(url))) {
            const result = await chrome.storage.local.get(['gptTabId', 'scriptInjected']);
            if (tabId === result.gptTabId && !result.scriptInjected) {
                await chrome.scripting.executeScript({
                    target: { tabId: tabId },
                    files: ['gpt-content.js']
                });
                await chrome.storage.local.set({ scriptInjected: true });
            }
        }
    }
});

chrome.runtime.onMessage.addListener(async (request, sender, sendResponse) => {
    if (request.action === 'openGPT') {
        const result = await chrome.storage.local.get(['gptUrl', 'launchedViaContextMenu', 'contentTabId']);
        const { gptUrl, launchedViaContextMenu, contentTabId } = result;

        if (launchedViaContextMenu && sender.tab.id === contentTabId) {
            chrome.tabs.get(contentTabId, async (tab) => {
                if (!tab) {
                    const gptTab = await chrome.tabs.create({ url: gptUrl, active: false });
                    await chrome.storage.local.set({ gptTabId: gptTab.id, scriptInjected: false });
                    await chrome.tabs.update(gptTab.id, { active: true });
                } else {
                    await chrome.tabs.update(contentTabId, { active: true });
                    await chrome.tabs.remove(contentTabId);
                    chrome.tabs.get(contentTabId, async (tab) => {
                        if (!tab) {
                            const gptTab = await chrome.tabs.create({ url: gptUrl, active: false });
                            await chrome.storage.local.set({ gptTabId: gptTab.id, scriptInjected: false });
                            await chrome.tabs.update(gptTab.id, { active: true });
                        }
                    });
                }
            });
        } else {
            const gptTab = await chrome.tabs.create({ url: gptUrl, active: false });
            await chrome.storage.local.set({ gptTabId: gptTab.id, scriptInjected: false });
            await chrome.tabs.update(gptTab.id, { active: true });
        }
    }
    sendResponse();
});
(function() {
    function getVisibleText() {
        let bodyText = '';

        function extractText(node) {
            if (node.nodeType === Node.TEXT_NODE) {
                if (node.textContent.trim().length > 0) {
                    return node.textContent;
                }
                return '';
            } else if (node.nodeType === Node.ELEMENT_NODE) {
                const tagName = node.tagName.toLowerCase();
                const excludedTags = ['script', 'style', 'img', 'svg', 'footer', 'nav', 'noscript'];

                if (excludedTags.includes(tagName)) {
                    return '';
                }

                const style = window.getComputedStyle(node);
                if (style.display !== 'none' && style.visibility !== 'hidden') {
                    let text = '';
                    node.childNodes.forEach(child => {
                        text += extractText(child);
                    });
                    return text;
                }
                return '';
            }
            return '';
        }

        document.body.childNodes.forEach(child => {
            bodyText += extractText(child);
        });

        return bodyText.trim();
    }

    const selectedText = window.getSelection().toString().trim();
    const textToProcesss = selectedText || getVisibleText();

    if (textToProcesss) {
        chrome.storage.local.set({ selectedText: textToProcesss }, () => {
            console.log('Text to summarize saved:', textToProcesss);
            chrome.runtime.sendMessage({
                action: 'openGPT'
            });
        });
    } else {
        alert('No text found on the page.');
    }
})();
(() => {
    const insertData = (data) => {
        const promptField = document.querySelector('#prompt-textarea');
        if (promptField) {
            promptField.value = data;
            const inputEvent = new Event('input', { bubbles: true });
            promptField.dispatchEvent(inputEvent);
        } else {
            console.error('Prompt textarea not found');
        }
    };

    const sendPrompt = () => {
        const sendButton = document.querySelector('[data-testid="fruitjuice-send-button"]');
        if (sendButton) {
            sendButton.click();
        } else {
            console.error('Send button not found');
        }
    };

    const waitForTopElementAndScroll = async () => {
        try {
            while (true) {
                let elements = document.querySelectorAll('[data-testid^="conversation-turn"]');
                if (elements.length > 0) {
                    let lastElement = elements[elements.length - 1];
                    lastElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    break; // Exit loop after scrolling
                }
                await new Promise(resolve => setTimeout(resolve, 500)); // Wait for 500ms before checking again
            }
        } catch (error) {
            console.error("Error scrolling to top of last element:", error);
        }
    };

    const handleProcess = async (selectedText) => {
        insertData(selectedText);
        sendPrompt();

        const observer = new MutationObserver((mutations) => {
            mutations.forEach((mutation) => {
                if (mutation.addedNodes.length) {
                    waitForTopElementAndScroll();
                }
            });
        });

        observer.observe(document.body, { childList: true, subtree: true });

        setTimeout(() => {
            observer.disconnect();
        }, 5000);
    };

    const init = async () => {
        try {
            const result = await chrome.storage.local.get(['selectedText']);
            const observer = new MutationObserver((mutations, observer) => {
                if (document.querySelector('#prompt-textarea')) {
                    handleProcess(result.selectedText);
                    observer.disconnect();
                }
            });

            observer.observe(document.body, { childList: true, subtree: true });
        } catch (error) {
            console.error("Error retrieving selected text from storage:", error);
        }
    };

    init();
})();
document.addEventListener('DOMContentLoaded', () => {
    document.getElementById('summarizeBtn').addEventListener('click', () => {
        chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
            chrome.scripting.executeScript({
                target: { tabId: tabs[0].id },
                files: ['content.js']
            });
        });
    });
});
